Bugfinder. Libft. Strlcat, function they didn't want to. Текст также на русском.  
Get_Next_Line Intra Pedagogy 

«While this may seem somewhat confusing, it was done...»
Речь пойдёт о том, как разобраться, что нужно сделать, чтобы рабочая версия ft_strlcat() появилась в вашей библиотеке, и при этом понимать почему именно так. Многие, кто читают эту статью, уже попытались представить, чем же занимается эта функция, – это незабываемое чувство озадаченности густо приправленное досадой и разочарованием от первых попыток реализовать код работающей ft_strlcat(). Знайте, что вероятно не только вы оказались недовольны, трудно сказать что в этой функции более скверное, документация или замысловатость идеи. Может быть именно это обстоятельство делает эту функцию изгоем стандартных библиотек и проблемной при переносе кода на другие машины. Я долго пытался разобраться со всей тщательностью, как то, что написано в man согласуется с тем, что делает функция. Благо теперь, по прошествии времени, информация во мне улеглась, и я пытаюсь кратко и ясно изложить суть.
Сперва я выпишу всё, что сообщает man ровно об этой функции, исключив сведения её не касающиеся:
size_t strlcat(char *dst, const char *src, size_t size); 
Description. Strlcat() functions concatenate strings. They are designed to be safer, more consistent, and less error prone replacements for strncat(3). Unlike this function, strlcat() take the full size of the buffer (not just the length) and guarantee to NUL-terminate the result (as long as size is larger than 0 or, in the case of strlcat(), as long as there is at least one byte free in dst). Note that a byte for the NUL should be included in size. Also notestrlcat() only operate on true ''C'' strings. This means that strlcat() both src and dst must be NUL-terminated. The strlcat() function appends the NUL-terminated string src to the end of dst. It will append at most size - strlen(dst) - 1 bytes, NUL-terminating the result.
Return Values. The strlcat() function returns the total length of the string it tried to create. That means the initial length of dst plus the length of src. While this may seem somewhat confusing, it was done to make truncation detection simple. Note, however, that if strlcat() traverses size characters without finding a NUL, the length of the string is considered to be size and the destination string will not be NUL-terminated (since there was no space for the NUL). This keeps strlcat() from running off the end of a string. In practice this should not happen (as it means that either size is incorrect or that dst is not a proper ''C'' string). The check exists to prevent potential security problems in incorrect code. 
Первое, что очевидно, эта функция занимается конкатенацией, т. е. записыванием символов одной строки после всех символов первой. (Тут стоит вспомнить, что слов строка используется в двух значениях, и чаще всего строка – это все символы до знака конца строки. Отсюда становиться проще понять, что такое пустая строка, хотя она занимает 1 байт, а не 0. Ну а второе значение, это тот участок памяти, который содержит строку и её конец). Второе, что обращает на себя внимание, что не хватит силы ни одной фантазии, чтобы найти возможным счесть, что тип возвращаемого значения прямо связан с основной работой этой функции. Оставьте магию волхвам, тут действительно нет прямой связи. Третье, это понятие названное по-английски buffer. Его стоит перевести как синоним предельного доступного места выделенного для результата операции. Сами придумайте название в одно, ну хотя бы два слова. В общем место под результат. И ещё, это пожалуй уже четвёртое, мы об этом обязательно поговорим в других заметках багоискателя (bugfinder) – одно из самых на мой важных понятий – ожидания от работы. Это и ожидания от работы функции, и ожидаемый результат и связанные с этим входные значения. Эта вещь между строк или явно, но неизбежно преследует каждый замысел каждого программиста. Наверное тем более этот замысел явный, чем более хорошо, популярно, изложена суть программы, функции и т. д. Так вот в этой функции явно сказано о том, что ожидается некий результат, а его полная длина и будет возвращена. Тут придётся стать детективами, и интуицией представить о чём идёт речь. Функция занимается конкатенацией. Это то основное, что она должна предъявить после того, как уйдёт на покой. А возвращает она бледный отблеск своей красочной жизни – численное отображение результата.
Сразу отвечу на тот вопрос, который заставил меня целый сутки потратить на одну из реализаций функции, а потом передумать и срубить всё под корень, так как результат воплощения не сходился с тестами: «strlcat() ... guarantee to NUL-terminate the result» и «the destination string will not be NUL-terminated». Присылайте свои письма с ответами как это может быть, а я пока буду двигаться дальше. Я взял реализацию этой функции в сети. Я рассматривал реализацию от FreeBSD, но у нас же маки, потому вот вам даже более короткая версия от Apple (ловите ссылки внизу). Не буду томить, суть такова: если размер места без 1 байта меньше длины строки назначения, то не будет произведено никакой конкатенации. И за первым символом строки назначения, выходящим за пределы места - 1 (минус 1 для знака конца строки) уже никто не следит. И никто не проверяет это строка Си (по определения строка си имеет окончание строки), или просто какая-то иная последовательность символов. Кстати, давайте это для определённости назовём случаем один. И останется на самом деле-то ещё всего лишь два случая.
Второй случай, это тот, в котором строк источника не умещается в отведённое пространство для присоединения её к строке назначения. Тогда копируется всё что может, за исключением 1 байта на то самое гарантированное окончание, на конец строки. Ну а остальное не копируется. Ох и дичь твориться с терминами, но я в конце ещё раз постараюсь всё подытожить и очень коротко всё обозначить. Ну а третий случай, это тот, в котором хватило места для полной конкатенации. Граничный случай, когда хватило тютелька в тютельку относите куда хотите.
Так, ну это то, что функция делает до завершения, а что же она возвращает?! А вот что! В первом случае – максимальную длину места (значение переменной size) плюс длину строки назначения. Кстати вот тут то, доверчивость с ожиданием нуль терминированной строки может подвести и работа программы под угрозой ошибка сегментации. Но расслабьтесь, тут мало что можно сделать. В остальных двух случаях длина строки назначения оказывается меньше длины места, и используется именно её (строки назначения) длина, а длина строки источника всё также неотступно следует за нами.
Какой в этом смысл так разделять результаты и возвращаемый результат, спросите вы. Ну это способ страховки верной работы. Во всех случаях, когда возвращаемый результат больше выделенного для операции места – конкатенация прошла не полностью. Возможно, я не знаю об этом, различить неверные случаи между собой, кто-то мог бы проверив равен ли последний байт концу строки.
Подытожим. Функция призвана склеивать две строки и возвращать показатель результатов работы. Третий параметр отвечает за предельное место, отведённое под результат. Если его хватает, чтобы впихнуть не только строку назначения, но и хоть что-то от строки источника, то склеивание происходит, а результирующая строка гарантировано нуль терминирована. Если нет, но склеивание даже не пытались начать и про конец строки никто и не вспоминает. В первом случае вернут сумму длин входных строк, во втором сумму длины выделенного места и строки назначения. И всё это время мы надеялись, что программа не завершиться неожиданно, когда строка назначения оказалась чем угодно, только не строкой Си.
Попробуйте для уяснения провести такие тесты:
Before :                || After :
dst   | src   | size    || dst      | return
------------------------||--------------------
dst\0 | src\0 | 0       || dst\0    | 3
dst\0 | src\0 | 1       || dst\0    | 4
dst\0 | src\0 | 2       || dst\0    | 5
dst\0 | src\0 | 3       || dst\0    | 6
dst\0 | src\0 | 4       || dst\0    | 6
dst\0 | src\0 | 5       || dsts\0   | 6
dst\0 | src\0 | 6       || dstsr\0  | 6
dst\0 | src\0 | 7       || dstsrc\0 | 6
dst\0 | src\0 | 8       || dstsrc\0 | 6

___
Реализация strlcat от FreeBSD. https://github.com/lattera/freebsd/blob/master/sys/libkern/strlcat.c Начните лучше с неё. Если сможете с нескольких подглядываний всё понять и написать самостоятельно, разрешаю вам гордиться собой весь день
Реализация strlcat от Apple. https://opensource.apple.com/source/Libc/Libc-825.26/string/strlcat.c.auto.html
Тесты взяты отсюда https://stackoverflow.com/questions/33154740/strlcat-is-dst-always-nul-terminated-what-are-size-and-the-returned-value

