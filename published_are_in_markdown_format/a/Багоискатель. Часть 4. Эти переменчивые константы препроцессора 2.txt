# Эти переменчивые константы препроцессора.

> Программисты Си, дойдя до определённого уровня квалификации, обязательно сталкиваются с одной из особенностей этого языка — макросами. Почти во всех других языках аналога макросов нет. И это неспроста. Использование макросов может оказаться весьма небезопасным. В них скрывается ряд особенностей, специфика которых не всегда лежит на поверхности. 
##### Такую, мотивирующую к регулированию использования макросов, информацию, можно найти на одном из [сайтов](https://tproger.ru/translations/c-macro/). 

Мы поговорим о смысле участка правила «II.7 Macros and Pre-processors. Mandatory part» Норм 2.0.2 английской и французской версий.  
__Английская версия Норм 2.0.2__
> - Preprocessor constants (or #define) you create must be used only for associate literal and constant values.

__Французская версия Норм 2.0.2__
> - Les constantes de préprocesseur (#define) que vous créez ne doivent être utilisés
que pour associer des valeurs littérales et constantes, et rien d’autre.

Вам всё понятно в этом правиле? Многие скажут: «Да». Если предложение понятно в целом, следует ли из этого, что понятны его части? Ответ тоже «да». Ответ нет, был бы связан скорее всего с какой-то мистикой. В этой статье без потусторонних сил, только лишь со здравым смыслом, логикой и рациональностью попробуем найти значение это пункта правил. Приступаем.

## Вопросы на которые предстоит ответить:
- как его перевести на русский язык.
- из каких частей состоит предложение.
- что означает каждая часть предложения.

### Переводы.
__Перевод с английского.__
> - Константы препроцессора (или #define), которые вы создаете, должны использоваться только для связывания литеральных и константных значений.

__Перевод с французского.__
> - Созданные вами константы препроцессора (#define) должны использоваться только для связывания литеральных и константных значений, и ничего больше.

### Разбор [предложения на части](https://en.wikipedia.org/wiki/Phrase_structure_rules)
Если вы хотите, можете прибегнуть к помощи роботов, чтобы проанализировать предложение: 

[дерево синтаксического разбора предложения. Вариант 1.][дерево синтаксического разбора предложения. Вариант 1.]
[Расшифровка.][Расшифровка условных обозначений диаграммы по варианту 1]
![Диаграмма 1. Дерево синтаксического разбора по первому варианту. ](https://cdn1.savepice.ru/uploads/2019/3/20/a791fbdc13837bcae4f63079e5ac2f07-full.png)

[Другой способ нарисовать дерево синтаксического разбора.](https://visl.sdu.dk/visl/en/parsing/automatic/trees.php) 
![Диаграмма 2.  Дерево синтаксического разбора по первому варианту. ](https://cdn1.savepice.ru/uploads/2019/3/20/ee5710384ba193cfcba3b8a2684c9f66-full.png)

[дерево синтаксического разбора предложения. Вариант 2.][дерево синтаксического разбора предложения. Вариант 2.]

[дерево синтаксического разбора предложения. Вариант 1.]: https://www.link.cs.cmu.edu/cgi-bin/link/construct-page-4.cgi#submit
[Расшифровка условных обозначений диаграммы по варианту 1]: https://visl.sdu.dk/visl2/info/world_of_grammar.pdf 
[дерево синтаксического разбора предложения. Вариант 2.]: https://yohasebe.com/rsyntaxtree/

Предложение:
- Группа подлежащего *Preprocessor constants (or #define) you create*.
 - ...
- Группа сказуемого *must be used*.
 - ...
- Группа обстоятельства *only for associate literal and constant values*.
 - …

## Далее по очереди разбирём каждую группы.

### Предварительные соображения.

Что входит в препроцессор:
> Препроцессором выполняются следующие действия: 
> - замена соответствующих диграфов и триграфов на эквивалентные символы «#» и «\»; 
> - удаление экранированных символов перевода строки;
> - замена строчных и блочных комментариев пустыми строками (с удалением окружающих пробелов и символов табуляции);
> - вставка (включение) содержимого произвольного файла (#include);
> - __*макроподстановки (#define)*__;
> - условная компиляция (#if, #ifdef, #elif, #else, #endif);
> - вывод сообщений (#warning, #error).

Отдельно отмечу, что препроцессор работает с лексемами, определёнными [стандартом Си](http://read.pudn.com/downloads133/doc/565041/ANSI_ISO%2B9899-1990%2B%5B1%5D.pdf) и только с ними. Лексемы препроцессора после макрозамены отображаются только в лексемы Си.
«6.1 Lexical elements. Syntax»

>  Each preprocessing token that is converted to a token shall have the lexical form of a keyword, an identifier, a string literal, an operator, or a punctuator.
> Перевод:
>> Каждая лексема предварительной обработки (препроцессии), преобразованная в лексему, должна иметь лексическую форму ключевого слова, определения (идентификатора), строкового литерала, оператора или пунктуатора.

|	token		|	preprocessing-token	|
|	-------------	|	-------------		|
|	<keyword>	|				|
|			|	<header-name>		|
|	<identifier>	|	<identifier>		|
|	<constant>	|				|
|			|	<character-constant>	|
|	<string-literal>	|	<string-literal>		|
|	<operator>	|	<operator>		|
|	<punctuator>	|	<punctuator>		|
|			|	<pp-number>		|
|			|	<each non-white-space character that cannot be one of the above>	|

Особенно остановимся на пункте __*«макроподстановки (#define)»*__  Синтаксис и значение макроподстановок определён [стандартом Си](http://read.pudn.com/downloads133/doc/565041/ANSI_ISO%2B9899-1990%2B%5B1%5D.pdf): «6.8 Preprocessing directives. 6.8.3 Macro replacement». Если нарисовать эту картинку крупными мазками, получиться следующее:

>  1. `#define <определение> <список заменяющих лексем>` // *константы препроцессора (`object-like macro`)*
>  2. `#define <определение>(список параметров) <список заменяющих лексем>` // *макросы (`function-like macro`)*
___

### Группа подлежащего **Preprocessor constants (or #define) you create**.
Основу по данному вопросу слагает раздел стандарта Си «6.8.3 Macro replacement». «Preprocessor constants» стандартом не определён (См. таблицу выше). Таким образом можно лишь надеяться понять этот термин, через исследование словоупотребления. Вряд ли найдётся другой доступный источник словоупотребления отличный от результатов поисковика в интернете.

Определяют  `Константу препроцессора` (`Preprocessor constants`) явно или в контексте как `object-like macro`, отсюда же `function-lile macro` нередко определён в этих источниках как `макрос`  ([1](https://habr.com/ru/post/246971/), [2](https://www.cprogramming.com/tutorial/cpreprocessor.html), [3](https://ru.wikipedia.org/wiki/Препроцессор_Си)
Другое определение можно найти в [4](https://books.google.ru/books?id=PsRKDAAAQBAJ&pg=PA56&lpg=PA56&dq=Preprocessor+constants&source=bl&ots=ztzrlYndAX&sig=ACfU3U2dsc-ibcVM-ucYT_Cbg0SSja4T6A&hl=ru&sa=X&ved=2ahUKEwi1jt7ChI_hAhXxlYsKHTlFDCo4ChDoATACegQIBhAB#v=onepage&q=Preprocessor%20constants&f=false), где `константу препроцессора` используется как синоним `symbolic constants`, эту же точку зрения можно найти в [5](https://www.quora.com/What-are-symbolic-constants-in-c-How-you-declare-them), [6](https://stackoverflow.com/questions/19379353/symbolic-constants-in-c-define-statement), [7](http://meramind.com/c-programming/symbolic-constants-c/).
___
> `Symbolic Constant` is a name that substitutes for a sequence of characters or a numeric constant, a character constant or a string constant.
> Перевод: 
>> `Символическая константа` - это имя, которое заменяет последовательность символов или числовую константу, символьную константу или строковую константу.

Таким образом хотя термин `константа препроцессора` не определён в стандарте Си, существует языковая практика, вводящая определение этого понятия, и это определение не единственно. Есть общее в этих определениях и отличия. 
Первое.
`#define <определение> <список заменяющих лексем>` 
Второе.
`#define <определение> <суженый список заменяющих лексем>`, где `<суженый список заменяющих лексем>`:  `<Integer Literals>`, `<Floating-point Literals>`, `<Character Constants>`, `<String Literals>` и ничего больше (см, что такое литерал в параграфе *literal*)

### Группа сказуемого __must be used__.  
Раздел мне кажется предельно очевидным, поэтому пояснения по нему я не даю.

### Группа обстоятельства **only for associate literal and constant values**.

#### only for associate
Неясно значение слова «associate». Это слово может быть определено и как прилагательное, и как глагол. Однако, при такой замене машинный перевод Гугл переводе «must be used for associate object one and object two» трактует это слово как глагол или существительное со значением действия: «должен использоваться для связывания объекта один и объекта два».

Особенно отмечу, что  слово «только» (only) зависимо от слова associate и никаких других слов. Таким образом `константа препроцессора` связывает только то, что указано за этим словом. _Если вы понимаете, чем ещё может заниматься директива #define с `константа препроцессора`, напишите._

#### literal and constant values 
##### literal
Это слово встречается в стандарте 28 раз. 27 раз в связке «string literal» и 1 раз как прилагательное «The success of literal matches» в значении «буквальное». Похоже ни одно из этих значений не может быть принято как использованное в исследуемом предложении. Придётся обратиться к практике словоупотребления в сети Интернет.
##### [literal](https://en.wikipedia.org/wiki/Literal_%28computer_programming%29) and [constant](https://en.wikipedia.org/wiki/Constant_%28computer_programming%29) values 
В сети не мало использования обоих терминов как синонимов:
1. Константа есть то же, что литерал. 
«Constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals». [1](https://www.tutorialspoint.com/cprogramming/c_constants.htm), [2](https://www.geeksforgeeks.org/constants-in-c/), [3](https://www.w3schools.in/c-tutorial/constants/), [4](https://codeforwin.org/2017/08/literals-c-programming.html), [5](https://www.quora.com/What-are-constants-in-C)
Так мы получаем, что константа есть синоним одного из членов множества: Integer Literals, Floating-point Literals, Character Constants, String Literals.
2. Константа включает литерал, но не равна ему. Константа — есть некоторое имя для непосредственного значения, которым является литерал. Подчёркивается роль опосредования.
[1](https://stackoverflow.com/questions/11732795/are-the-literal-and-constant-the-same-concept-in-c), [2](https://www.diffen.com/difference/Constant_vs_Literal), [3](https://www.tutorialspoint.com/What-is-the-difference-between-literal-and-constant-in-Cplusplus)
3. Расширение представления о константе. В этой заметке рассуждают о литеральной (заданной непосредственно в коде) и символической (заданной опосредованно через препроцессор) константах.[«Summary: this tutorial introduces you to C constants including literal constants and symbolic constants.»](http://www.zentut.com/c-tutorial/c-constants/)

#### Обобщаем раздел для **Группы обстоятельства**
Хотя всё равно уверенности в найденном понимании данной фразы будет не максимальным, наибольший смысл «only for associate literal and constant values» имеет: **1** _только для связывания постоянных и буквальных значений_. Вообще говоря это перечисление открыто. Т.е. их можно связывать ещё с чем-то, но один из указанных элементов в этой связке должен присутствовать. Приведём это к функциональным обозначениям. _Связывать((константы или литералы), нечто третье)_. При этом константа препроцессора не может выступать литералом. Тогда: _Связывать(константу препроцессора, нечто третье)_. А если привлекать ещё перевод французкого текста, то кажется, что определённости становится больше:  **2** _только для связывания постоянных и буквальных значений, и ничего больше_. Так перечисление уже закрыто. И глагол связывать выступает двухместной функцией:  _Связывать(константу препроцессора, (константы или литералы))_. Отметим, что есть ещё одно значение, которое интуитивно здесь напрашивается: **3** _связывать(константу, литерал)_. Если считать французский вариант правил важнее английского, тогда возможны только 2 или 3. Хотя установить какое из двух значений имеется ввиду не представляется возможным.

При этом ни в одном из случаев не удаётся понять значение слова константа включает константу препроцессора, равную определению, или не включает. Потому возможны следующие варианты:
1. `#define <определение> <любое число лексем из списка: определение OR Integer Literals OR Floating-point Literals OR Character Constants OR String Literals>`
2. `#define <определение> <только одна лексема из списка: Integer Literals OR Floating-point Literals OR Character Constants OR String Literals>`

## Заключение.
К сожалению, наиболее важный документ для регламентации проектирования программ студентами школы «42» содержит участки, которые выражены очень ненадёжно, многозначность которых достигает почти неограниченного числа вариантов, хотя базовых шаблона скорее всего только два. Я считаю, что исследуемый в этой статье пункт Норм должен быть переписан так, чтобы он имел ясность и однозначность. Для этого хорошо бы, чтобы стало ясно какой из двух предлагаемых вариантов верный.

 > 1. `#define <определение> <любое число лексем из списка: определение OR Integer Literals OR Floating-point Literals OR Character Constants OR String Literals>`
 > 2. `#define <определение> <только одна лексема из списка: Integer Literals OR Floating-point Literals OR Character Constants OR String Literals>`

Оба определяют работу директивы #define для случаев, когда определения (идентификаторы) не имеют параметров. При это в первом случае собрано огромное множество комбинаций, что может быть разрешено. Второй случай – пример крайности, когда разрешён ровно один конкретный шаблон макроподстановки. Всего комбинаций очень много. Второй случай, есть частный случай первого, если внимательно рассмотреть их. 

Я знаю, что многие студенты очень уверены в том, что значит этот пункт правил. Хотя если собрать их всех вместе и опросить, окажется, что предметы их уверенности несхожи между собой. Хотя это не мешает при проверках снижать оценки или не уметь поспорить, когда это снижение было предложено. На мой взгляд полезнее и безболезненнее для себя и окружающих отдавать себе ясный отчёт в том, что есть пункты правил, норм, других участков заданий проектов школы, которые не имеют одной единственной трактовке и воздерживаться проявлять токсичность. 

#### Желаю вам счастья и интереса в учёбе.
