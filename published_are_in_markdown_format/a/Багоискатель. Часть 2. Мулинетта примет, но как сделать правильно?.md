Bugfinder. Get_Next_Line. Moulinette will accept, but how to do it right? Текст также на русском.

Широко распространённое решение есть лишь частный случай данного задания. Так это или нет? – Давайте разбираться*.

Цель задания сформулирована например на титульном листе проекта:

«The aim of this project is to make you code a function that returns a lineending with a newline, read from a file descriptor.»

также в тексте, например на странице 6:

«•Write a function that returns a line read from a file descriptor.
  •What we call a “line” is a succession of characters that end with ’\n’ (ascii code0x0a) or withEnd Of File(EOF).» Если увлеклись чтением, то можно его продолжить, открыв сам документ с заданием, страницу вы знаете. 

Предлагаю разобраться с тем, что называедся рядом. Обозначим  символ ’\n’ (перенос строки) через  έ, а любой другой символ через a. Других символов нет. Ответьте исходя из формулировки задания, какую запись должна сделать get_next_line(), обработав файлы следующего содержания (всё содержимое файла только эти символы):
    1. έ
    2. a
    3. aέ
    4. έa
    5. έέa
    6. aaέa
Я не тороплю вас. Прошу ответить по каждому пункту. Готовы? Переходим дальше. Обозначим через λ символ ’\0’ (конец строки). Какой результат ожидаете от таких файлов?
    1. έ
    2. λ
    3. λέ
    4. έλ
    5. έέλ
    6. λλέλ
Если посмотрите на огромное количество экземпляров кода с решеениями от студентов школы «42», то обнаружите, что используются строковые функции. Большая часть этих функций создаёт дополнительный байт в конце каждой записи и помещает туда λ. Заметье также, что строковые функции типа ft_strchr(), ft_strlen(), ft_strsub() в своём коде предполагают обязательное наличие λ, а также полагают λ ограничением их действия. Т.е. выходит, что get_next_line(), реализованная со строковыми функциями постулирует второй разделитель: έ – первый, который указан в задании, и λ – второй, постулированный програмистами, реализовавшими код get_next_line() на основе строковых функций. На сколько это верно? 

Можно считать, что ряд и строка – суть одно явления. Как бы вёл седя текст задания если бы эти два слова были синонимами? По всей видимости эти два термина свободно бы заменяли один другой. Но если вы внимательно просмотрите тескт, или просто воспользуетесь <cmd>+<f>, то обнаружите ровно 0 (ноль) упоминаний слова string в тексте. Вывод, который напрашивается, line != string. И определение line дано: это последовательность символов, оканчивющаяся έ. (Подробнее о том, что такое строка можно узнать из стандарта Си как 89, так и 99 годов например из параграфа «5.2  Environmental considerations 5.2.1  Charactersets»). Таким образом, выходит, что все реализации кода студентами «42», которые можно найти на github, все мало того используют второй разделитель, которого нет в задании (т. е. их решение уже, чем в задании, их решение – подмножество решений задания), так ещё и дописывают символы, о которых не говориться в задании. Последняя часть не повзоляет мне понять, является ли реальная реализация подможеством всех возможных решений задания или вовсе с ним не пересекается. Однако мулинетта, я знаю, такие задания принимает. Я не могу понять почему. Но назревает вопрос.

Внимание вопрос. Если и сдать код, который  заменит функции ft_strchr() на ft_memchr(), ft_strlen() на подачу числа байт, и ft_strsub() – на ft_memjoin() и т.д., и код в результате будет удовлетворять описанным в тексте задания условиям, как должны быть написаны тесты, чтобы такой код, и код подавляющего большинства решений был принят? Или же, использование только одного разделителя, έ, и не дописывания рядов дополнительным символом λ, а также записывание строк, представленных например некоторым числом символов λ, является строго недопустимым Мулинеттой решением?


* Речь будет идти об английской версии задания https://cdn.intra.42.fr/pdf/pdf/776/get_next_line.en.pdf
